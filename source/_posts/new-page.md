---
 title: 腾讯笔试后知后觉
 tags: [笔试]
 type: tags
---

## 笔试题目
>如下示例：   
 1：0种分解方法；     
 2：0种分解方法；   
 3=2+1 1种分解方法；   
 4=3+1 =2+1+1 2种分解方法；  
 5=4+1 =3+2 =3+1+1 =2+2+1 =2+1+1+1 5种分解方法；  
 6=5+1 =4+2 =4+1+1 =3+2+1 =3+1+1+1 =2+2+1+1= 2+1+1+1+1 共七种分解方法；  
 以此类推，求整数n共有几种分解方法。（如输入2，输出0）

## 题目解读
>  题目中所示的分解方法其实是将一个大整数n分解成m个数相加，但m个数不能是完全相同的。
 
## 解题思路
> 很可惜在笔试时间内没能做出来这道题，当时的思路是如果按照手写分解方法，总是将上一种分解方法的一个数拆开，所以最后一种分解方法永远是2+1+1+...(n-2个1)，所以倒数第二种分解方法就是将最后一种方法中的两个1或者1和2组合起来，即2+2+1+1...(n-4个1)或3+1+1+1..(n-3个1)。但一直没能用代码实现。

> 笔试结束后稍稍改变了一下思路，如果能先将该数的所有分解方法计算出来，再计算出所有加数完全相同的分解方法数，就能求得题目所要的分解方法次数。基于这个思路，问题的关键就在如何求得n的所有分解方法count1以及加数相同的分解方法count2。 
  
> 柿子挑软的捏，先解决简单的问题，先求出count2。这个问题可以转换一下思路，如果n可以由i个m相加得到，那么m和i都是n的因数，所以这个问题就转化为求整数n的因数问题，这就只需要遍历从1到n<sup>1/2</sup>，假设得出结果为x。如果n是一个完全平方数，那2x-1，反之为2x。  

> 接下来要求出count1。既然要求出所有的输出组合，那就意味一定会有一个遍历所有组合的过程，并且这个遍历一定是按照某种顺序的，所以关键问题在如何从第一种分解方法遍历到最后一种分解方法。先看一个例子：
> >3=1+1+1 =1+2 =2+1 =3  
  
> 这个过程中的1+2和2+1本质上只是一种分解方法，所以应当先规定一个次序，定义了次序，剩下的就是让程序按照这个顺序执行下去。所以我们让数组从小到大出现，也就是说后一个加数永远大于等于前一个加数，这样就不会出现上面2+1的情况了，这样一来就能保证输出的唯一性了。

> 剩下的就是递归了，先遍历1开头的组合，当1开头的组合遍历完成时，就开始遍历2开头的，以2开头的分解方法中就没有加数1了，最小的加数为2；可以看出，第一个数最大的情况是取小于等于n/2的最大整数，如果第一个数大于n/2,而后一个数又必须大于n/2,那么两数相加一定会大于你，递归的思路如下：
> >n=1+后续组合   
> >n=2+后续组合    
> >...   
> >...   
> >n=n/2(前取整)+p   (n为偶数时p=n/2,n为奇数时p=(n+1)/2)

>思路差不多到这里，接下来是代码实现了。递归函数为total(n,start)，n为需要分解的整数，start表示当前遍历的第一个数字，start主要是为了去重复的。

### javascript实现
```
//从1开始，后面加的每个数都大于等于1
//1计算完了从2开始，一直遍历到比number/2小的最大整数
var count1 = 0;//记录可能性总数（包括所有加数完全一样）
var count2 = 0;//计算所有加数都相等情况的总数
function list(number){
  if (parseInt(number)==NaN) {//判断输入是否有效
    return false;
  }
  if (number<3) {//n小于3时直接输出0
    return 0;
  }
  total(number,1);//从第一个加数为1开始执行递归
  for(var m = 1;m<=parseInt(Math.sqrt(number));m++){
    if((number/m)==(parseInt(number/m))){//判断n的因数个数
      count2++;
    }
  }
  console.log(count1,count2);//调试，可忽略
  //判断n是否是完全平方数，若为完全平方，则根号n被多减去了一次，需要加上
  if((parseInt(Math.sqrt(number)))==Math.sqrt(number)){
    return count1-count2*2+2;
  }else{
    return count1-count2*2+1;
  }
  
}
function total(number,start){
  for(var i = start;i<=number/2;i++){
    total(number-i,i);//从i开始可排除重复
    count1++;
  }
}
console.log(list(9));//结果为27
```


 